---
title: 3분 모나드  
date: 2020-05-16  
description: 그래서... 모나드가 뭔지 알고 싶으시다고요?  
somethings: 2  
keywords: 모나드, monad, 함수형 프로그래밍
---

주위에 함수형 프로그래머가 있으시다면, 하다못해 함수형 프로그래밍 커뮤니티 근처라도 가보셨다면, 한 번쯤은 꼭 들어 보셨을 법한 단어가 있습니다.
**모나드(*monad*)**요.

![펀셔널좌](./funcool.png)

함수형 프로그래머들은 모나드를 매우 좋아합니다. 아니, 사랑합니다. 그들 중 누군가는 지금 모나드가 그려진 내복을 입고 모나드를 사용하며 프로그래밍을 하고 있을지도 모릅니다.
그런데 도대체 왜 그들은 모나드를 그리도 좋아하는 걸까요? 그들이 좋아하는 모나드란 도대체 무엇일까요? 궁금하지 않으신가요?
저는 매우 궁금했었습니다. 그래서 모나드 공부를 시작했었고, 그렇게 2년동안 토끼굴 속에서 출구를 찾아 돌아다니는 고통스러운 나날이 시작되었었습니다.

저는 모나드를 이해하기까지 2년 가까이 걸렸었습니다.
어쩌다 접한 '모나드'라는 개념을 이해하기위해 하스켈도 공부하고, 수학도 공부하고, 논문들도 읽어보고, 참 다사다난했지요.(듣고 계십니까 코기님? 선생님이 3년 전에 슬랙에서 모나드 이야기를 하신 게 기억 나세요???)
기본도, 자료도, 지도도 없이 모나드를 이해하는 여정을 떠났었기에, 기하학에 왕도는 없다고 한 유클리드도 제가 걸어온 길을 보면 '그렇다고 해서 일부러 진흙탕을 휘젓고 다니라는 말은 아니었는데...' 라고 할 수 있을 정도로 매우 험난하고 뒤틀린 길을 걸었었습니다.
그렇기에 이 여정을 끝내고 나니 이런 생각이 들더군요. "만약 내가 지도를 가지고 있었다면 조금은 수월하게, 빠르게 모나드를 익힐 수 있지 않았을까?"

그래서 이 글을 그려 보았습니다. 모나드를 완전하게 설명하지는 않지만 모나드가 무엇인지에 대한 큰 틀과 앞으로 공부해야 할 것들의 윤곽을 잡아주는 지도를요.
부디 과거의 저 처럼 모나드를 이해하기 위해 고생하시는 분들에게 도움이 되었으면 좋겠습니다.

그럼 이제 본격적으로 이야기를 시작해 보도록 하지요.

## 두 개의 관점

저는 어떤 개념을 공부할 때, 크게 두 가지 관점에서 그 개념을 살펴봅니다.
1. 이것의 정의는 무엇인가? -- 개념의 겉뜻, 겉모습 탐구
2. 이것이 의미하는 바는 무엇인가? -- 개념의 속뜻, 시사하는 바 탐구

개념의 겉뜻을 모르면 개념을 사용할 수 없습니다. 마치 그림을 못 그리는 사람들이 그림 그릴 때 처럼요. 머릿속에서는 온갖 상상이 펼쳐지지만 손은 그걸 도화지에 투영해내지 못합니다.
개념의 겉뜻을 모르는 경우도 마찬가지입니다. 개념을 어떻게 활용할 지에 대한 대략적인 형태와 배경은 존재하나 이를 직접 실제적인 것으로 투영해내지는 못합니다.
반대로 개념의 속뜻을 모르면 개념을 활용할 수 없습니다. 마치 수학 심화 문제를 풀 때 처럼요. 문제를 읽어 보면 무슨 기술을 써야 할 지는 알 거 같은데, 그걸 어떻게 써야 할 지 도통 알 수 없는 것입니다.
개념의 속뜻을 모르는 경우도 마찬가지입니다. 무엇이 그 개념에 해당하는지는 알지만, 그 개념을 가지고 사고를 발전시키지는 못합니다.

이렇게, **개념의 겉뜻과 속뜻은 처음에는 정말 상이해보이지만 신기하게도 결국 하나로 합쳐져 온전한 개념을 이룹니다**.
그렇기에 저는 어떠한 개념을 이해함에 있어 두 관점에서의 관찰이 이루어지지 않으면 안 된다고 생각하며, 이 글 또한 마찬가지로 두 개의 관점에서 모나드를 소개하는 형태로 써 보려고 합니다.

## 첫 번째 관점에서의 관찰, 모나드의 정의는 무엇인가?

**어떤 타입 `M`에 대해 아래의 세 함수, `fmap`과 `pure`, 그리고 `join`이 존재할 때, `M`은 모나드입니다.**

```typescript
// (a: A) => B로 M<A>를 M<B> 타입의 값으로 만드는 함수 (M<A>에 함수('f'unction)를 매핑('map'ping)하는 함수)
declare function fmap<A, B>(ma: M<A>, f: (a: A) => B): M<B>;
// A를 M<A>로 만드는 함수
declare function pure<A>(a: A): M<A>;
// M<M<A>>를 M<A>로 만드는 함수 (M<M<A>>의 두 M을 합치는 함수)
declare function join<A>(mma: M<M<A>>): M<A>;
```

네, 이게 프로그래밍 세계에서의 모나드의 정의입니다. 생각보다 많이 간단하지요? 우리에게 친숙한 프로그래밍 언어로, 프로그래밍 세계라는 수학보다 훨씬 한정적인 범위 내에서 정의해서 그렇습니다.
우리가 알고 싶은 건 프로그래밍 세계에서의 모나드지, 수학에서의 모나드가 아니니까요. 프로그래밍 세계에서의 정의로도 충분하지요.

이렇게 정의를 하나 보여드렸으니, 이번에는 구체적인 사례를 보여드리겠습니다.
아래는 `Maybe`라는 모나드로, 모나드 중에서 간단한 축에 속하는 녀석입니다.

```typescript
type Maybe<A> = A | null;

function fmap<A, B>(ma: Maybe<A>, f: (a: A) => B): Maybe<B> {
  if (ma === null) return null;
  else return f(ma);
}

function pure<A>(value: A): Maybe<A> {
  return value;
}

function join<A>(mma: Maybe<Maybe<A>>): Maybe<A> {
  if (mma === null) return null;
  else return mma; 
}
```

지금 기분이 알 듯 말 듯, 반쪽만 배운 기분이시라면, “그래서 이게 뭐? 무엇이 모나드인지는 알겠는데 이게 프로그래밍에서 갖는 의미가 뭔데?” 싶으시다면 여러분은 정상이십니다! 왜냐하면 제가 아직 모나드의 반쪽만 설명해드렸기 때문이죠.
반쪽만 듣고 전체를 다 알아내는 사람이 있으면 그건 그 분이 뛰어나신 겁니다. 원래 반쪽만 들어선 모르는 게 정상이에요.
오히려 제가 설명한 반쪽, 겉뜻을 완전히 이해하신 거니 잘 하신 겁니다. 그럼 이제 나머지 반쪽, 속뜻에 대해서 이야기 해 보도록 하지요.

## 두 번째 관점에서의 관찰, 모나드가 의미하는 바는 무엇인가?

우리는 프로그램을 작성할 때, 어떤 연산이 존재하고, 어떤 데이터가 어떤 연산으로 처리되어야 할 지를 서술하곤 합니다.
그렇기에 프로그램은 '연산의 명세'라고도 볼 수 있습니다.
이 관점에서 **연산은 프로그램을 구성하는 뼈대로, 프로그래밍에 있어 빼놓기 어려운 매우 중요한 요소**라고 할 수 있겠습니다.

하지만, 안타깝게도 프로그래머들은 보통 값을 우대하곤 합니다.
그말인 즉슨, 값을 어떻게 잘 모델링할 지를, 추상화 할 지를 고민하지 연산을 어떻게 모델링 하고 취급할 지는 잘 고민하지 않는다는 말입니다.
일반적으로, 단순한 함수를 통해 연산을 어떻게 표현할 지를 제외하면 심도 깊은 고민들을 잘 하지 않죠.
하지만 프로그램을 '연산의 명세'로 보는 관점에 따르면 연산은 데이터만큼이나 프로그래밍에 있어 중요한 요소입니다.
그러니 연산들에 대해 이야기 해 봅시다.

추상화의 한 방식으로, **분류(*classification*)**란 방식이 존재합니다. **분류란 말 그대로 공통적인 속성을 갖는 구체적인 사례들을 분류하여 추상적인 개념을 만들어 내는 방식**입니다.
예컨대, 프로그래밍 언어들의 모음이 있을 때 '자바', 'C++', '자바스크립트'와 같이 '객체'를 중심적으로 다루는 언어들을 따로 묶음으로서 '객체 지향 프로그래밍 언어'라는 하나의 추상적인 개념을 만들 수 있지요.
이렇게 공통적인 속성을 갖는 구체적인 사례들을 분류하여 새로운 카테고리를 만드는 일, 그것이 분류입니다.
그럼 이번에는 연산들을 분류해 봅시다.
정말 다양한 분류가 나올 수 있을 텐데요, 그 중에서 저는 '나눗셈', '배열에서 첫 번째 요소 가져오기'라는 '예외를 발생시키는 경우가 존재하는 연산'들을 따로 묶어서 '실패할 수 있는 연산'이라는 하나의 추상적인 개념을 만들어 보았습니다.

이렇게 연산들을 분류하고 보니 실패할 수 있는 연산에 무엇이 있는지는 알 수 있을 것 같습니다. 그런데 이걸 어떻게 표현할 수 있을까요?
'실패할 수 있는 연산'은 구체적으로 어떻게 정의해야 하는 걸까요? 단순히 '나눗셈과 같은 것, 배열에서 첫 번째 요소를 가져오는 것과 같은 것'이라고 할 수는 없잖아요.
이런 미약한, 느슨한 정의로는 어떤 연산이 실패할 수 있는 연산이고, 어떤 연산이 아닌 지 구별하기가 어렵습니다. 좀 더 **명확하고 구체적인 언어**가 필요합니다.

다행히도, 우리가 사용하는 프로그래밍 언어들은 이런 미약한 방식으로 연산들을 정의하지 않습니다. 대신, **의미론(*semantic*)이라는 것을 활용해 연산에 대한 충분히 명확하고 구체적인 정의**를 내리지요.
연산 의미론(*operational semantic*), 표기 의미론(*denotational semantic*), 공리 의미론(*axiomatic semantic*) 등 정말 다양한 종류의 의미 구조가 존재하는데요, 그 중 오늘 다룰 것은 범주 의미론(*categorical semantic*)입니다.

**범주 의미론은 쉽게 말해 카테고리 이론(*category theory*, a.k.a 범주론)의 개념들로 연산을 정의하는 방식**입니다.
그리고 모나드는 바로 카테고리 이론의 개념이지요.
감이 오시나요?

그렇습니다. 프로그래밍에서 **모나드는 연산을 정의하고, 추상화 하기 위해 쓰이는 것**입니다.
하지만 아직 의문점은 남아있습니다. 어떤 연산을 정의한다는 것이며 모나드로 연산을 정의하면 무엇이 좋길래 함수형 프로그래머들은 이걸 그리도 좋아하는 걸까요?
먼저, 연산을 왜 추상화 해서 다루는 지를 생각해 봅시다.

제네릭 프로그래밍(*generic programming*)을 아시나요? **제네릭 프로그래밍은 여러 데이터들에 대해 일반적인, 즉, 유연한 코드를 작성함으로서 재사용성을 끌어올리는 방식**입니다.

```typescript
class List<T> {
  public readonly head: T;
  public readonly tail?: List<T>;

  constructor(head: T, tail?: List<T>) {
    this.head = head;
    this.tail = tail;
  }
}
```

모든 타입에 대해, 각 타입의 리스트는 담고 있는 값은 다를지언정 리스트 자체의 구조는 항상 가장 앞 부분과 뒷 부분이 있다는 점에서 같지요.
위의 코드는 이를 이용한 제네릭 프로그래밍의 예 입니다.

그렇다면, 만약 데이터들 뿐만 아니라 연산마저 추상화를 한다면 어떨까요? 코드의 재사용성이 더 증폭되겠지요? 이것이 바로 연산을 추상화하는 이유입니다.
그리고 이 '연산 추상화'에 있어, 어떤 연산이 범주 의미론에서 모나드로 추상화 된다면 그 연산은 '합칠 수 있음'이 보장됩니다.
수학적으로, 모나드의 성질이 바로 '합칠 수 있음'이기 때문이죠. 즉, **모나드는 '합칠 수 있는 연산'을 정의하고 추상화 하기 위해 쓴다**고 할 수 있겠습니다.
그럼 여기서 또 다른 의문점이 생깁니다. 연산이 합쳐질 수 있다는 것은 어떤 의미를, 그리고 가치를 갖는 걸까요?

프로시저, 서브루틴, 함수, 익숙한 이름이죠? 그렇다면 부프로그램(*subprogram*)은 들어 보셨나요? 이 이름들은 모두 연산을 추상화 할 때 쓰이는 개념의 이름입니다.
조금씩 세부 사항이 다를 뿐, 근본은 모두 같지요. 그런데 잠시만, 지금 부 **프로그램**이라고요?
그렇습니다. 사실 함수들은 부프로그램, 다시 말해 프로그램 속의 프로그램입니다. 그리고 함수는 연산을 추상화 하는, 연산을 나타내는 개념이지요.
그말인 즉슨, **'모든 프로그램은 곧 연산'이라는 말입니다! 그리고 모나드로 정의되는 연산은 합쳐질 수 있습니다!** 이제 모나드의 매력을 아시겠나요?

정리해 보지요.

어떤 연산이 모나드라면, 그 연산은 합칠 수 있습니다.
프로그램은 곧 연산이고, 연산은 곧 프로그램입니다.
그렇기에 **어떤 연산이 모나드라면, 그 연산에 해당하는 모든 프로그램은 합쳐질 수 있습니다!**
(일례로, '입출력 연산'은 모나드입니다. 그렇기에 하스켈 프로그래머들은 '입출력 연산'을 하는 프로그램을 합치며 프로그램을 만들지요.)

**연산을 추상화할 수 있는 능력, 연산을 정의할 수 있는 능력, 연산을 합쳐 새로운 연산을 만들 수 있는 능력, 더 나아가 프로그램을 합쳐 새로운 프로그램을 만들 수 있는 능력, 이 모든 것이 바로 모나드의 능력입니다.**

지금까지의 모든 이야기를 종합하자면 모나드의 속뜻, 즉, **어떤 연산이 모나드임이 시사하는 바는 그 연산은 합성할 수 있다는 점**이라는 겁니다.

## 두 관점 합치기, 모나드란 무엇인가?

지금까지 각 관점에서 모나드를 관찰해 보았습니다. 마지막으로 관찰한 것들을 합쳐 모나드의 전체적인 모습을 보도록 하겠습니다.

첫 번째 관점에서 모나드를 관찰할 때, 저는 어떤 타입 `M`이 특정 조건을 만족할 때 그 타입을 모나드라 부른다고 했습니다.
왜 연산을, 프로그램을 직접적으로 추상화하는 함수가 아니라 타입에 대해서 모나드인지 아닌지 이야기를 하는 걸까요?

그 이유는 모든 프로그램을 어떤 값 `A`를 가지고 어떤 연산 `T`를 하여 `B` 타입의 값을 내놓는 함수라고 볼 수 있다는 점에서 찾을 수 있습니다.
마치 일차방정식의 기본형이 `ax + b = 0` 인 것처럼 모든 프로그램의 기본형은 `A -> T<B>` 인 거지요.
그리고 여기서 알 수 있는 것은, `A`와 `B`는 항상 중복되기 때문에 **어떤 특정 연산에 해당하는 프로그램을 나타내기 위해 필요한 것이 `T` 타입 뿐**이라는 점입니다.
그렇기 때문에 우리는 **번거롭게 매번 프로그램의 기본형을 통해 연산을 정의하지 않고, `T` 타입만 정의하여 연산을 정의**하는 거지요.

다음으로, 첫 번째 관점에서 모나드의 정의를 소개할 때, 저는 어떤 타입 `M`이 모나드가 되려면 그 타입에 대해 세 함수, `fmap`과 `pure`, 그리고 `join`이 존재해야 한다고 했습니다.
여기서 이 세 함수, `fmap`, `pure`, `join`이 갖는 의미는 무엇일까요? 그리고 왜 하필 이 세 함수인 걸까요?

그 이유는 연산 `T`의 합성을 `fmap`과 `pure`, 그리고 `join` 세 함수로 표현할 수 있다는 점에서 찾을 수 있습니다.
즉, **`fmap`, `pure`, `join`은 어떤 연산을 합성하는 각종 연산들을 만들 수 있는 아주 기본적인 빌딩 블록**이라는 이야기이지요.
예컨대, 두 연산 `T`를 합성하는 함수, `fish`는 아래와 같이 `fmap`과 `pure`, 그리고 `join`을 통해 작성할 수 있습니다.

```typescript
type Maybe<A> = A | null;

function fmap<A, B>(ma: Maybe<A>, f: (a: A) => B): Maybe<B> {
  if (ma === null) return null;
  else return f(ma);
}

function pure<A>(value: A): Maybe<A> {
  return value;
}

function join<A>(mma: Maybe<Maybe<A>>): Maybe<A> {
  if (mma === null) return null;
  else return mma; 
}

function fish<A, B, C>(f: (a: A) => Maybe<B>, g: (b: B) => Maybe<C>): (a: A) => Maybe<C> {
  return (a: A) => join(fmap(f(a), g));
}
```

이렇게 두 관점에서 관찰한 내용들을 합쳐 보았습니다. 이제 모나드가 무엇인지 정의를 내릴 때가 되었군요.

**모나드란, 자신에 대해 세 함수 `fmap`과 `pure`, 그리고 `join`이 존재하여 스스로를 합성할 수 있는 연산을 나타내는 타입 `M`입니다.**

## 마무리

고생 많으셨습니다. 지금까지 여러분은 모나드의 거의 모든 것을 배우셨습니다. 남은 건 제가 그려드린 밑그림을 구체적인 지식들로 채워나가실 일 뿐입니다.
물론 앞으로의 일들이 마냥 쉽지만은 않을 겁니다. 그동안 이해한 것이 부정당할 때도 있고, 머릿속이 혼란스러워 질 때도 있으실 겁니다.
그렇지만 제가 이것 하나만은 보장해 드리겠습니다. 여기까지 잘 인내하면서 공부하신 여러분이라면 언젠가는, 머지않아 모나드를 꼭 이해하게 되실겁니다.
그러니 절대 낙담하지 마시고, 계속해서 나아가세요.

그럼, 마지막으로 오늘 다룬 내용을 정리하며 글을 마치도록 하겠습니다. 긴 글 읽어주셔서 감사합니다.

- 모나드의 겉뜻: **어떤 타입 `M`에 대해 세 함수, `fmap`과 `pure`, 그리고 `join`이 존재할 때, `M`은 모나드이다.**
- 모나드의 속뜻: **어떤 연산이 모나드임이 시사하는 바는 그 연산은 합성할 수 있다는 점이다.**
- 모나드: **자신에 대해 세 함수 `fmap`과 `pure`, 그리고 `join`이 존재하여 스스로를 합성할 수 있는 연산을 나타내는 타입 `M`.**

## 읽을거리

- [Category theory for programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)
모나드의 고향인 카테고리 이론을 프로그래밍의 개념들을 통해 설명하는 시리즈입니다. 모나드 이외에도 정말 많은 카테고리 이론의 개념들이 설명되어 있습니다.
카테고리 이론을 정석대로 이해하고 싶으시다면 이 시리즈를 추천드립니다. 덧붙이자면, 유튜브에 실제 강의를 찍은 [영상](https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_)도 있습니다. 영상을 선호하신다면 유튜브에서 보시는 걸 추천드립니다.

- [Monads are just monoids in the category of endofunctors](https://blog.merovius.de/2018/01/08/monads-are-just-monoids.html)
모나드가 수학적으로 무엇인지 빠르게, 그러나 너무 얕지는 않게 익혀보고 싶으시다면 이 글을 추천드립니다. 선수 지식들을 포함한 속성 강좌입니다.

- [A categorical view of computational effects](http://www.math.jhu.edu/~eriehl/lambda.pdf)
프로그래밍에서 모나드를 도입한 이론적인 배경을 설명하는 슬라이드입니다. 실제 컨퍼런스 발표의 슬라이드로, 유튜브에서 [영상](https://www.youtube.com/watch?v=Ssx2_JKpB3U&t=2036s)을 보실 수도 있으니 영상을 선호하신다면 유튜브에서 보시는 걸 추천드립니다.

- [Monads for functional programming](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
프로그래밍의 관점에서 모나드를 설명하는 글입니다.

- [Comprehending Monads](https://ncatlab.org/nlab/files/WadlerMonads.pdf)
처음으로 프로그래밍에 모나드를 도입한 Philip Wadler의 논문입니다. 모나드의 시작이 궁금하시다면 보시는 걸 추천드립니다.