---
title: 3분 모나드  
date: 2020-05-16  
description: 그래서... 모나드가 뭔지 알고 싶으시다고요?  
somethings: 2  
keywords: 모나드, monad, 함수형 프로그래밍
---

> **NOTICE**: 이 글은 단순히 아는 분께 모나드를 설명하기 위해 급하게 새벽에 쓴 글이라 난이도 조절, 문장 다듬기 등 일반적으로 거치는 작업들을 생략한 상태입니다.
> 그렇기에 글이 조금 조잡할 수 있습니다. 이 점 양해 부탁드립니다
> 차후 시간이 날 때 글은 다듬어 보도록 하겠습니다.

주위에 함수형 프로그래머가 있다면, 하다못해 함수형 프로그래밍 커뮤니티 근처라도 가보셨다면 한 번쯤은 꼭 들어 보셨을 법한 단어가 있습니다.
'모나드'요. 함수형 프로그래머들은 모나드를 매우 좋아합니다. 혹시 몰라요, 여러분들 주위 누군가는 집에서 모나드가 그려진 내복을 입고 생활할 지도요.

도대체 그들은 모나드를 그리도 좋아하는 걸까요? 궁금하지 않으신가요?
그렇다고 함수형 프로그래머들에게 모나드가 무엇이냐고 물으시면 안 됩니다. 다들 머리를 쥐어뜯으며 '음...' '어..' '그니까...' 를 반복하다 결국 "모나드는 엔도펑터들의 카테고리에서의 모노이드야!" 라는 요상한 주문을 외고 쓰러질 테니까요.
그치만, 여기서 당황하시고 구글에 모나드를 검색하시면 안 됩니다. 그래봤자 여러분들이 들으실 수 있는 대답은 같거든요. (아니, 어쩌면 다를지도 모릅니다. 구글은 이미지로도 대답을 하거든요.)

![모나드는 엔도펑터들의 카테고리에서의 모노이드일 뿐입니다](./monad-meme.jpeg)

이쯤 되면 대부분 포기하시고 마십니다. 알쏭달쏭, 도통 모르겠는 설명들 사이에서 헤엄치는 일은 전혀 쉽지 않기 때문이죠.
하지만 여전히, 끈기와 오기를 지니고 모나드를 이해하려 계속해서 몸부림 치는 분들도 늘 있으십니다.(예전에 저 처럼요.)
그런 분들에게 조금이나마 도움이 되었으면 하는 마음으로 이 글을 준비해 보았습니다.

저는 모나드를 이해하기까지(지금도 완전히 이해한 건 아닙니다만.) 1년 가까이 걸렸었습니다.
어쩌다 접한 '모나드'라는 개념을 이해하기위해 하스켈도 공부하고, 수학도 공부하고 논문들도 읽어보고, 참 다사다난했지요.(듣고 계십니까 코기님? 선생님이 2년 전에 슬랙에서 모나드 이야기를 하신 게 기억 나세요???)
저는 충분한 기본도, 자료도, 지도도 없이 모나드를 이해하는 여정을 떠났고, 그 댓가로 매우 험난하고 이상한 경로로 모나드를 익히게 됬습니다.
그렇기에 이 여정을 끝내고 나니 이런 생각이 들더군요. "만약 내가 지도를 가지고 있었다면 조금은 수월하게, 빠르게 모나드를 익힐 수 있지 않았을까?"

그래서 이 글을 그려 보았습니다. 모나드를 완전하게 설명하지는 못하지만 모나드가 무엇인지에 대한 큰 틀과 앞으로 공부해야 할 것들의 윤곽을 잡아주는 지도를요.
그럼 이제 본격적으로 이야기를 시작해 보도록 하겠습니다.

## 두 개의 관점

저는 어떤 개념을 공부할 때, 크게 두 가지 관점에서 그 개념을 살펴봅니다.
1. 무엇이 이것인가? -- 개념의 겉모습, 겉뜻 탐구
2. 이것이 의미하는 바는 무엇인가? -- 개념이 시사하는 바, 속뜻 탐구

개념은 동전과 같습니다. 두 개의 전혀 다른 그림이 양면에 있어 보는 위치에 따라 알 수 있는 것이 다르지만, 실제로는 '하나' 이기 때문입니다.
그리고 저는 개념이라는 동전의 양면에 그려진 그림은 각각 겉뜻과 속뜻이라고 생각합니다.
처음에는 놀랍도록 상이하지만 신기하게도 결국에는 하나로 합쳐져 온전한 개념을 이루기 때문이죠.(겉뜻만 알면 개념을 응용할 수 없고, 속뜻만 알면 개념을 사용할 수 없습니다.)

그렇기에 저는 어떠한 개념을 이해함에 있어 두 관점에서의 관찰이 이루어지지 않으면 안 된다고 생각하며, 이 글 또한 마찬가지로 두 개의 관점에서 모나드를 소개하는 형태로 써 보려고 합니다.

## 첫 번째 관점에서의 관찰, 무엇이 모나드인가?

어떤 타입 `M`에 대해 아래의 세 함수, `fmap`과 `pure`, 그리고 `join`이 존재할 때, `M`은 모나드입니다.

```typescript
// (a: A) => B로 M<A>를 M<B> 타입의 값으로 만드는 함수 (M<A>에 함수('f'unction)를 매핑('map'ping)하는 함수)
declare function fmap<A, B>(ma: M<A>, f: (a: A) => B): M<B>;
// A를 M<A>로 만드는 함수
declare function pure<A>(a: A): M<A>;
// M<M<A>>를 M<A>로 만드는 함수 (M<M<A>>의 두 M을 합치는 함수)
declare function join<A>(mma: M<M<A>>): M<A>;
```

네, 이게 프로그래밍 세계에서의 모나드의 정의입니다. 생각보다 많이 간단하지요? 프로그래밍 언어로, 프로그래밍 세계라는 수학보다 훨씬 한정적인 범위 내에서 정의해서 그렇습니다.
우리가 알고 싶은 건 프로그래밍 세계에서의 모나드지, 수학에서의 모나드가 아니니까요. 프로그래밍 세계에서의 정의로도 충분하지요.

이렇게 정의를 하나 보여드렸으니, 이번에는 구체적인 사례를 보여드리겠습니다.
아래는 `Maybe`라는 모나드로, 모나드 중에서 간단한 축에 속하는 녀석입니다.

```typescript
type Maybe<A> = A | null;

function fmap<A, B>(ma: Maybe<A>, f: (a: A) => B): Maybe<B> {
  if (ma === null) return null;
  else return f(ma.value);
}

function pure<A>(value: A): Maybe<A> {
  return value;
}

function join<A>(mma: Maybe<Maybe<A>>): Maybe<A> {
  if (mma === null) return null;
  else return mma.value; 
}
```

지금 기분이 알 듯 말 듯, 반쪽만 배운 기분이시라면, “그래서 이게 뭐? 무엇이 모나드인지는 알겠는데 이게 프로그래밍에서 갖는 의미가 뭔데?” 싶으시다면 여러분은 정상이십니다! 왜냐하면 제가 아직 모나드의 반쪽만 설명해드렸기 때문이죠.
반쪽만 듣고 전체를 다 알아내는 사람이 있으면 그건 그 분이 뛰어나신 겁니다. 원래 반쪽만 들어선 모르는 게 정상이에요.
오히려 제가 설명한 반쪽, 겉뜻을 완전히 이해하신 거니 잘 하신 겁니다. 그럼 이제 나머지 반쪽, 속뜻에 대해서 이야기 해 보도록 하지요.

## 두 번째 관점에서의 관찰, 모나드가 의미하는 바는 무엇인가?

프로그램이란 무엇일까요? 여러 관점이 있겠지만, 지금 이야기 할 관점은 프로그램을 '연산의 명세'라고 보는 관점입니다.
프로그램을 연산의 명세로 본다 함은, 프로그램이 데이터에 대해 어떻게, 어떤 연산을 실행해야 하는지를 적어둔 설명서로 본다는 말이지요.
이 관점에서, 프로그래밍에 있어 연산은 빼놓기 어려운 매우 중요한 요소입니다.

하지만 안타깝게도, 프로그래머들은 보통 값들을 우대하곤 합니다.
그말인 즉슨, 값들을 어떻게 잘 모델링할 지를, 추상화 할 지를 고민하지 연산을 어떻게 모델링 하고 취급할 지는 잘 고민하지 않는다는 말입니다.
단순한 함수를 통해 연산을 어떻게 표현할 지를 제외하면 심도 깊은 고민들을 잘 하지 않죠.
하지만 프로그램을 '연산의 명세'로 관점에 따르면 연산은 데이터 만큼이나 프로그래밍에 있어 중요한 요소입니다.
그렇다면 지금 한번 연산들을 추상화 해 보지요.

추상화의 한 방식으로, '분류'(classification)란 방식이 존재합니다. '분류'란 말 그대로 구체적인 사례들을 분류하여 추상적인 개념을 만들어 내는 방식입니다.
예컨대, 프로그래밍 언어들의 모음이 있을 때 '자바', 'C++', '자바스크립트'와 같이 '객체'를 중심적으로 다루는 언어들을 따로 분류하여 묶음으로서 '객체 지향 프로그래밍 언어'라는 하나의 추상적인 개념을 만들 수 있지요.
이렇게 구체적인 사례들을 분류하여 새로운 카테고리를 만드는 일, 그것이 분류입니다.
그렇다면 이번에는 연산들을 분류해 봅시다.
정말 다양한 분류가 나올 수 있을 텐데요, 그 중에서 저는 '나눗셈', '배열에서 첫 번째 요소 가져오기'라는 '예외를 발생시키는 경우가 존재하는 연산'들을 따로 묶어서 '실패할 수 있는 연산'이라는 하나의 분류를, 추상적인 개념을 만들어 보았습니다.

이렇게 연산들을 분류하고 보니 실패할 수 있는 연산에 무엇이 있는지는 알 수 있을 것 같습니다. 그런데 이걸 어떻게 표현할 수 있을까요?
'실패할 수 있는 연산'은 구체적으로 어떻게 정의해야 하는 걸까요? 단순히 '나눗셈과 같은 것, 배열에서 첫 번째 요소를 가져오는 것과 같은 것'이라고 할 수는 없잖아요.
이런 미약한, 느슨한 정의로는 어떤 연산이 실패할 수 있는 연산이고, 어떤 연산이 아닌 지 구별하기가 어렵습니다. 좀 더 명확하고 구체적인 언어가 필요합니다.

다행히도, 우리가 사용하는 프로그래밍 언어들은 이런 미약한 방식으로 연산들을 정의하지 않습니다. 대신, 의미 구조(semantic)이라는 것을 활용해 연산에 대한 충분히 명확하고 구체적인 정의를 내리지요.
연산 의미론(operational semantic), 표기 의미론(denotational semantic), 공리 의미론(axiomatic semantic) 등 정말 다양한 종류의 의미 구조가 존재하는데요, 그 중 오늘 다룰 것은 categorical semantic입니다.

categorical semantic은 쉽게 말해 카테고리 이론(category theory)의 개념들로 연산을 정의하는 방식입니다. 그리고, 모나드는 바로 카테고리 이론의 개념이지요.
감이 오시나요?

그렇습니다. 프로그래밍에서 모나드는 연산을 정의하고, 추상화 하기 위해 쓰이는 것입니다.
하지만 어떤 연산을요? 모나드로 연산을 정의하면 무엇이 좋길래 함수형 프로그래머들은 이걸 그리도 좋아하는 걸까요?
먼저, 연산을 왜 추상화 해서 다루는 지를 생각해 봅시다.

제네릭 프로그래밍을 아시나요? 제네릭 프로그래밍은 여러 데이터들에 대해 일반적인, 즉, 유연한 코드를 작성함으로서 재사용성을 끌어올리는 방식인데요.
데이터들 뿐만 아니라 만약 연산마저 추상화를 한다면 어떨까요? 코드의 재사용성이 더 증폭되겠지요? 이것이 바로 연산을 추상화하는 이유입니다.
그리고 이 '연산 추상화'에 있어, 어떤 연산이 categorical semantic에서 모나드로 추상화 된다면 그 연산은 '합칠 수 있음'이 보장됩니다.
수학적으로, 모나드의 성질이 바로 '합칠 수 있음'이기 때문이죠. 즉, 모나드는 '합칠 수 있는 연산'을 정의하고 추상화 하기 위해 쓴다고 할 수 있겠습니다.
아직 이게 왜 좋은지 감이 잘 안 오신다고요? 괜찮습니다. 더 설명해 드릴게요.

프로시저, 서브루틴, 함수, 익숙한 이름이죠? 그렇다면 '부프로그램'(subprogram)은 들어 보셨나요? 이 이름들은 연산을 추상화 할 때 쓰이는 개념의 이름입니다.
조금씩 세부 사항이 다를 뿐, 근본은 모두 같지요. 그런데 잠시만, 지금 부 '프로그램'이라고요?
그렇습니다. 사실 함수들은 부프로그램, 다시 말해 프로그램 속의 프로그램입니다. 그리고 함수는 연산을 추상화 하는, 연산을 나타내는 개념이지요.
그말인 즉슨, '모든 프로그램은 곧 연산'이라는 말입니다! 이제 모나드의 능력을 아시겠나요?

정리해 보지요.

어떤 연산이 모나드라면, 그 연산은 합칠 수 있습니다.
프로그램은 곧 연산이고, 연산은 곧 프로그램입니다.
그렇기에 어떤 연산이 모나드라면, 그 연산에 해당하는 모든 프로그램은 합쳐질 수 있습니다!

그 예로, '입출력 연산'은 모나드입니다. 그렇기에 우리는 '입출력 연산'을 하는 모든 프로그램을 합칠 수 있지요.
연산을 추상화할 수 있는 능력, 연산을 정의할 수 있는 능력, 연산을 합쳐 새로운 연산을 만들 수 있는 능력, 더 나아가 프로그램을 합쳐 새로운 프로그램을 만들 수 있는 능력, 이 모든 것이 바로 모나드의 능력입니다.

지금까지의 모든 이야기를 종합하자면 모나드의 속뜻, 즉, (어떤 연산이) 모나드임이 시사하는 바는 그 연산은 합성할 수 있다는 점이라는 겁니다.

## 결론

고생 많으셨습니다. 지금까지 여러분은 모나드의 거의 모든 것을 배우셨습니다. 남은 건 제가 그려드린 밑그림을 구체적인 지식들로 채워나가실 일 뿐입니다.
물론 앞으로의 일들이 마냥 쉽지만은 않을 겁니다. 그동안 이해한 것이 부정당할 때도 있고, 머릿속이 혼란스러워 질 때도 있으실 겁니다.
그렇지만 제가 이것 하나만은 보장해 드리겠습니다. 여기까지 잘 인내하면서 공부하신 여러분이라면 언젠가는, 머지않아 모나드를 꼭 이해하게 되실겁니다.
그러니 절대 낙담하지 마시고, 계속해서 나아가세요.

그럼, 마지막으로 오늘 다룬 내용을 정리하며 글을 마치도록 하겠습니다. 긴 글 읽어주셔서 감사합니다.

- 모나드의 겉뜻: 어떤 타입 `M`에 대해 아래의 세 함수, `fmap`과 `pure`, 그리고 `join`이 존재할 때, `M`은 모나드이다.
- 모나드의 속뜻: 어떤 연산이 모나드임이 시사하는 바는 그 연산은 합성할 수 있다는 점이다.

## 읽을거리

- [Category theory for programmers](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)
모나드의 고향인 카테고리 이론을 프로그래밍의 개념들을 통해 설명하는 시리즈입니다. 모나드 이외에도 정말 많은 카테고리 이론의 개념들이 설명되어 있습니다.
카테고리 이론을 정석대로 이해하고 싶으시다면 이 시리즈를 추천드립니다. 덧붙이자면, 유튜브에 실제 강의를 찍은 영상도 있습니다. 영상을 선호하신다면 유튜브에서 보시는 걸 추천드립니다.

- [Monads are just monoids in the category of endofunctors](https://blog.merovius.de/2018/01/08/monads-are-just-monoids.html)
모나드가 수학적으로 무엇인지 빠르게, 그러나 너무 얕지는 않게 익혀보고 싶으시다면 이 글을 추천드립니다. 선수 지식들을 포함한 속성 강좌입니다.

- [A categorical view of computational effects](http://www.math.jhu.edu/~eriehl/lambda.pdf)
프로그래밍에서 모나드를 도입한 이론적인 배경을 설명하는 슬라이드입니다. 실제 컨퍼런스 발표의 슬라이드로, 유튜브에서 영상을 보실 수도 있으니 영상을 선호하신다면 유튜브에서 보시는 걸 추천드립니다.

- [Monads for functional programming](https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
프로그래밍의 관점에서 모나드를 설명하는 글입니다.

- [Computational lambda-calculus and monads](https://person.dibris.unige.it/moggi-eugenio/ftp/lics89.pdf)
프로그래밍에 모나드를 처음 도입한 Eugenio Moggi의 논문입니다. 모나드의 시작이 궁금하시다면 보시는 걸 추천드립니다(초록에만 해도 재밌는 이야기들이 많이 있습니다.).