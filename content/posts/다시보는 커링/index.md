---
title: 다시보는 커링  
date: 2021-02-11  
description: 커링에 대해 더 깊게 알아봅시다.  
somethings: 1  
keywords: 커링, Currying, 함수형 프로그래밍, functional programming
---

# 다시보는 커링

커링을 설명하는 글은 이미 인터넷에 많이 있습니다. 그렇기에 이 글은 단순히 커링을 설명하는 글이 되어서는 안 됩니다. 한편, 대부분의 커링을 설명하는 글은 커링의 정의를 소개하는 선에서 그칩니다. 그리고 그렇기에 이 글은 커링을 깊게, 아주 깊게 설명하는 글이 될 예정입니다.

어쩌면 생각치도 못하고 지나갔을 흥미로운 이야기들을, 혹은 왜 그런지 의문을 품고 있었을 질문들에 대한 시원한 답들을 지금 풀어보도록 하겠습니다.

## 커링이란 무엇인가?

커링은 다인수 함수를 일인수 함수의 열로 나타내는 표현 방식입니다. 함수에게 있어 중요한 것은 연산에 필요한 값들을 모두 제공받는 일이지 이를 몇 번에 걸쳐 나누어 받는지가 아니라는 아이디어에 기반하고 있습니다.

```javascript
const f = (x, y, z) => x + y + z;
const fC1 = x => y => z => x + y + z;
const fC2 = x => (y, z) => x + y + z;
const fC3 = (x, y) => z => f(x, y, z);

// 위 네 개의 함수는 모두 요구하는 값과 그 값을 가지고 하는 계산이 일치합니다.
```

주어진 함수에 커링을 적용하는 방식은 간단합니다. 그저 모든 매개변수를 쪼개어 한 개씩 받도록 함수를 잘게 나누면 그만입니다. 예컨대 매개변수 `n`, `m`을 받아야 한다면 `n`을 받고, `m`을 받아 연산을 수행하고 결과를 반환하는 함수를 반환하는 함수를 만들면 됩니다.

```javascript
const f = (n, m) => ...
const curriedF = n => m => ...
```

커링을 꼭 프로그래머가 직접 손으로만 해야 하는 것은 아닙니다. 함수를 이용하여 함수를 커링하는 과정을 추상화 할 수도 있습니다.

```javascript
/** 
 * 귀납적으로 정의한 커링 함수
 * 
 * 1. 0인수 함수를 커링하면 0인수 함수입니다.
 * 2. 1인수 함수를 커링하면 1인수 함수입니다.
 * 3. n + 1인수 함수를 커링하면 커링된 n인수 함수를 반환하는 1인수 함수입니다.
 *    (n + 1인수 함수는 n인수 함수를 반환하는 1인수 함수와 같기 때문입니다.)
 * **/

function curry(f) {
  function makeNArgFunction(arity, f) {
    return Object.defineProperty(f, 'length', { value: arity });
  }

  if (f.length <= 0) return f;
  else return arg => curry(makeNArgFunction(f.length - 1, (...args) => f(arg, ...args)));
}
```

## 커링의 시사점

커링은 형태는 다르지만 동작은 같은 함수들이 존재할 수 있음을 시사합니다. 다른 말로는, 하나의 함수가 여러 해석을 가질 수도 있고 여러 함수를 하나의 함수로 통합하여 생각할 수도 있음을 커링은 우리에게 제시합니다. 이 아이디어는 간단하게는 각 함수가 한 개의 매개변수만 가질 수 있는 람다 대수에서 다인수 함수를 표현하는 데에 쓰이며 더 나아가서는 함수에 대해 고찰할 때에도 유용하게 사용됩니다. 예컨대, `<A, B>(xs: A[], f: (x: A) => B) => B[]` 타입의 `map` 함수를 커링하면 `<A>(xs: A[]) => <B>(f: (x: A) => B) => B[]` 타입의 함수가 됩니다. 그리고 다시 이 함수의 두 매개변수의 순서를 바꾸면 `<A, B>(f: (x: A) => B) => (xs: A[]) => B[]` 타입의 함수가 됩니다. 눈치 채신 분도 계시겠지만, `map` 함수를 커링하고 두 매개변수의 위치를 바꾸어 만들어 낸 이 함수는 `lift`라 불리는 함수입니다. 주어진 일반적인 값에 대한 일반적인 함수를 배열에 대해 작동하는 특수한 함수로 다루는 값의 차원을 끌어올려 주는 함수이지요. 이렇게 단순히 커링과 매개변수의 위치를 바꾸는 작업을 통해 하나의 함수에 대한 다양한 해석이 가능합니다.

```typescript
function map<A, B>(xs: A[], f: (x: A) => B): B[] {
  if (xs.length === 0) return [];
  else return [f(xs[0]), ...map(xs.slice(1), f)];
}

const lift: <A, B>(f: (x: A) => B) => (xs: A[]) => B[] = f => xs => map(xs, f);

function inc(x: number): number {
  return x + 1;
} 

const incForArray = lift(inc);

incForArray([1, 2, 3, 4, 5]); // [2, 3, 4, 5, 6] 반환
```

## 부분 적용과 커링

함수의 매개변수 중 일부를 고정하는 기술로 부분 적용이 있습니다. 부분 적용을 사용하면 함수의 추상도를 낮추어 더 구체적인 함수를 만들어 낼 수 있습니다.

```javascript
function fixParameter(f, ...args1) {
  return (...args2) => f(...args1, ...args2);
}

function add(n, m) {
  return n + m;
}

const inc = fixParameter(add, 1);

inc(2); // 3 반환
```

만약 부분 적용을 수행한 함수가 커링된 함수라면, 별도의 부분 적용을 위한 함수나 그에 준하는 중간자가 필요하지 않습니다.

```javascript
const add = n => m => n + m;
const inc = add(1);

inc(2); // 3 반환
```

## 자동 커링과 하스켈의 함수 호출 문법

몇몇 프로그래밍 언어에서는 모든 함수가 기본적으로 커링되어 제공됩니다. 그 중에서도 하스켈과 같은 ML류 프로그래밍 언어들은 커링에 최적화된 함수 호출 문법을 프로그래머에게 제공합니다. 이들의 함수 호출 문법에는 모든 함수가 커링되어 있다는 그 특성에 맞추어, 매개변수를 구분하는 컴마 따위의 표지가 존재하지 않으며 모든 함수 호출은 스페이스를 통해 구별됩니다. 예를 들어 세 수를 더하는 함수 `add`를 하스켈에서 호출한다면 다음과 같은 코드를 사용합니다.

```haskell
add 1 2 3
```

만약 자바스크립트에서 같은 함수를 호출한다면 아래와 같이 매 호출을 구별해 주는 소괄호를 사용하여 번잡한 코드를 작성해야 했을 겁니다.

```javascript
add(1)(2)(3);
```

ML류 프로그래밍 언어들의 이러한 자동 커링 기능과 커링에 최적화된 함수 호출 문법은 프로그래머에게 더 나은 함수형 프로그래밍 경험을 제공해 줍니다.

----

이번 글에서는 커링에 대한 심도 깊은 이야기들을 풀어 보았습니다. 사실 커리-하워드 대응을 통해 보았을 때 커링이 논리학에서 무엇에 대응하는지와 같이 조금 더 수학적인 이야기들도 해보고 싶었습니다만, 제 능력과 이해가 부족해서 아직 거기까지는 논리정연하게 설명하기 어려워 다음 기회로 미루었습니다. 혹시 궁금하신 분들은 커리-하워드 대응에 대해 알아보시면서 커링을 다시 살펴보세요. 흥미로운 점을 관찰하실 수 있으실 겁니다.

저는 여기서 이만 말을 줄이도록 하겠습니다. 긴 글 읽어주셔서 감사합니다.

